use std::fs::File;
use std::io::{BufReader, Cursor, Write};
use std::path::Path;

use byteorder::{LittleEndian, ReadBytesExt, WriteBytesExt};
use itertools::Itertools;
use rand::random;
use thiserror::Error;

use crate::bytes::FixedLengthByteArrays;
use crate::encryption::{Crypter, PCCrypter};
use crate::packets::quest::*;
use crate::packets::{PacketError, PacketHeader};
use crate::quest::bin::{QuestBin, QuestBinError};
use crate::quest::dat::{QuestDat, QuestDatError};
use crate::text::LanguageError;

#[derive(Error, Debug)]
pub enum QuestQstError {
    #[error("I/O error while processing quest qst")]
    IoError(#[from] std::io::Error),

    #[error("String encoding error during processing of quest qst string data")]
    StringEncodingError(#[from] LanguageError),

    #[error("Error reading quest qst data packet")]
    DataPacketError(#[from] PacketError),

    #[error("Bad quest qst data format: {0}")]
    DataFormatError(String),

    #[error("Error processing quest bin")]
    QuestBinError(#[from] QuestBinError),

    #[error("Error processing quest dat")]
    QuestDatError(#[from] QuestDatError),
}

#[derive(Debug)]
pub struct QuestQst {
    bin_header: QuestHeaderPacket,
    dat_header: QuestHeaderPacket,
    bin_chunks: Box<[QuestDataPacket]>,
    dat_chunks: Box<[QuestDataPacket]>,
}

fn encrypt_quest_data(
    quest_data: &mut [u8],
    decompressed_size: usize,
) -> Result<Box<[u8]>, QuestQstError> {
    let crypt_key = random::<u32>();

    // yes, PC encryption is used even for gamecube qst files
    let mut crypter = PCCrypter::new(crypt_key);
    crypter.crypt(quest_data);

    let mut result = Vec::<u8>::with_capacity(8 + quest_data.len());
    result.write_u32::<LittleEndian>(decompressed_size as u32)?;
    result.write_u32::<LittleEndian>(crypt_key)?;
    result.write_all(quest_data)?;
    Ok(result.into_boxed_slice())
}

fn decrypt_quest_data(quest_data: &mut [u8]) -> Result<&[u8], QuestQstError> {
    let mut prefix = &quest_data[0..8];
    let _decompressed_size = prefix.read_u32::<LittleEndian>()?;
    let crypt_key = prefix.read_u32::<LittleEndian>()?;

    // yes, PC encryption is used even for gamecube qst files
    let mut crypter = PCCrypter::new(crypt_key);
    let mut result = &mut quest_data[8..];
    crypter.crypt(&mut result);
    Ok(result)
}

fn create_quest_data_chunks(
    quest_data: &[u8],
    filename: &str,
    is_online_quest: bool,
) -> Result<Box<[QuestDataPacket]>, QuestQstError> {
    let mut chunks = Vec::<QuestDataPacket>::new();
    for (index, chunk) in quest_data.chunks(QUEST_DATA_PACKET_DATA_SIZE).enumerate() {
        let mut chunk = QuestDataPacket::new(&filename, chunk, is_online_quest)?;
        chunk.header.flags = index as u8;
        chunks.push(chunk);
    }
    Ok(chunks.into_boxed_slice())
}

fn extract_quest_chunk_data(
    chunks: &[QuestDataPacket],
    is_online_quest: bool,
) -> Result<Vec<u8>, QuestQstError> {
    // TODO: rewrite this function, it is kinda sloppy ...

    let mut data = Vec::<u8>::new();
    for chunk in chunks.iter() {
        data.write_all(&chunk.data[0..(chunk.size as usize)])?;
    }

    let actual_data = if is_online_quest {
        data
    } else {
        decrypt_quest_data(&mut data)?.into()
    };

    Ok(actual_data)
}

impl QuestQst {
    pub fn from_bindat(bin: &QuestBin, dat: &QuestDat) -> Result<QuestQst, QuestQstError> {
        let is_online = !bin.header.is_download; // "download quest" = "offline quest" (because it is played from a memory card ...)
        let quest_name = &bin.header.name;
        let quest_number = bin.header.quest_number_u16(); // i hate the quest .bin quest_number u8/u16 confusion amongst PSO tools ...
        let bin_filename = format!("quest{}.bin", quest_number);
        let dat_filename = format!("quest{}.dat", quest_number);

        let mut bin_bytes = bin.to_compressed_bytes()?;
        let mut dat_bytes = dat.to_compressed_bytes()?;
        if !is_online {
            // offline quests are encrypted with some extra bits added before the encrypted data
            bin_bytes = encrypt_quest_data(bin_bytes.as_mut(), bin.calculate_size())?;
            dat_bytes = encrypt_quest_data(dat_bytes.as_mut(), dat.calculate_size())?;
        }

        let bin_header = QuestHeaderPacket::new(
            quest_name,
            bin.header.language,
            &bin_filename,
            bin_bytes.len(),
            is_online,
        )?;

        let dat_header = QuestHeaderPacket::new(
            quest_name,
            bin.header.language,
            &dat_filename,
            dat_bytes.len(),
            is_online,
        )?;

        let bin_chunks = create_quest_data_chunks(bin_bytes.as_ref(), &bin_filename, is_online)?;
        let dat_chunks = create_quest_data_chunks(dat_bytes.as_ref(), &dat_filename, is_online)?;

        Ok(QuestQst {
            bin_header,
            dat_header,
            bin_chunks,
            dat_chunks,
        })
    }

    pub fn from_file(path: &Path) -> Result<QuestQst, QuestQstError> {
        let file = File::open(path)?;
        let mut reader = BufReader::new(file);
        Ok(Self::from_bytes(&mut reader)?)
    }

    pub fn from_bytes<T: ReadBytesExt>(reader: &mut T) -> Result<QuestQst, QuestQstError> {
        let mut bin_header: Option<QuestHeaderPacket> = None;
        let mut dat_header: Option<QuestHeaderPacket> = None;
        let mut bin_chunks = Vec::<QuestDataPacket>::new();
        let mut dat_chunks = Vec::<QuestDataPacket>::new();
        let mut bin_data_counter: usize = 0;
        let mut dat_data_counter: usize = 0;

        // loop, continuing to read packets until we have ALL of the following:
        // - a bin header
        // - a dat header
        // - bin data chunks that contain the exact number of bytes specified by the bin header
        // - dat data chunks that contain the exact number of bytes specified by the dat header
        //
        // the way this reading works should allow for the maximum amount of flexibility of the qst
        // file layout. though, most (all?) things that create qst files will follow this ordering:
        // - bin and dat header (either bin+dat or dat+bin)
        // - interleaved bin and dat chunks
        //
        // however, i have observed that fuzziqer servers (newserv, khyller) generally sends out
        // quest packets un-interleaved. that is, these servers send out bin header + bin data, and
        // then dat header + dat data (actually, i think the ordering might be dat first ...? meh)
        //
        // thus, i decided that even if there is only a very small chance that someone out there
        // saved a qst file in such a "non-standard" format, that we could easily account for any
        // of those variations here
        while (bin_header.is_none()
            || (bin_header.is_some()
                && bin_data_counter < bin_header.as_ref().unwrap().size as usize))
            || (dat_header.is_none()
                || (dat_header.is_some()
                    && dat_data_counter < dat_header.as_ref().unwrap().size as usize))
        {
            // what type of packet is this?
            let packet_header = PacketHeader::from_bytes(reader)?;
            match packet_header.id {
                PACKET_ID_QUEST_HEADER_ONLINE | PACKET_ID_QUEST_HEADER_OFFLINE => {
                    // there can only be one bin and dat header per qst file
                    if bin_header.is_some() && dat_header.is_some() {
                        return Err(QuestQstError::DataFormatError(String::from(
                            "Encountered more than two header packets",
                        )));
                    }

                    let header = QuestHeaderPacket::from_header_and_bytes(packet_header, reader)?;

                    // the header packet must include a filename, as this is used to determine
                    // whether it is for a .bin or .dat file
                    if header.filename.as_unpadded_slice().len() == 0 {
                        return Err(QuestQstError::DataFormatError(String::from(
                            "Encountered header packet with blank filename",
                        )));
                    }

                    match header.file_type() {
                        QuestPacketFileType::Bin => {
                            if bin_header.is_some() {
                                return Err(QuestQstError::DataFormatError(String::from(
                                    "Encountered duplicate bin file header packet",
                                )));
                            } else {
                                bin_header = Some(header);
                            }
                        }
                        QuestPacketFileType::Dat => {
                            if dat_header.is_some() {
                                return Err(QuestQstError::DataFormatError(String::from(
                                    "Encountered duplicate dat file header packet",
                                )));
                            } else {
                                dat_header = Some(header);
                            }
                        }
                        QuestPacketFileType::Unknown => {
                            return Err(QuestQstError::DataFormatError(String::from(
                                "Unable to determine file type from filename in header packet",
                            )));
                        }
                    }
                }
                PACKET_ID_QUEST_DATA_ONLINE | PACKET_ID_QUEST_DATA_OFFLINE => {
                    // data chunk packets must come after its associated header packet
                    // (e.g. .bin data chunks must follow the .bin header, same for .dat ...)
                    if bin_header.is_none() && dat_header.is_none() {
                        return Err(QuestQstError::DataFormatError(String::from(
                            "Encountered data chunk packet before any header packets",
                        )));
                    }

                    let chunk = QuestDataPacket::from_header_and_bytes(packet_header, reader)?;

                    // the data chunk packet must include a filename, as this is used to determine
                    // whether it is for a .bin or .dat file
                    if chunk.filename.as_unpadded_slice().len() == 0 {
                        return Err(QuestQstError::DataFormatError(String::from(
                            "Encountered data chunk packet with blank filename",
                        )));
                    }

                    // small sanity check, technically would not be a problem, but there shouldn't
                    // be any "blank" data chunk packets
                    if chunk.size == 0 {
                        return Err(QuestQstError::DataFormatError(String::from(
                            "Encountered data chunk packet with zero-length data",
                        )));
                    }

                    match chunk.file_type() {
                        QuestPacketFileType::Bin => {
                            if bin_header.is_none() {
                                return Err(QuestQstError::DataFormatError(String::from("Encountered data chunk packet for bin file before its header packet")));
                            } else {
                                bin_data_counter += chunk.size as usize;
                                bin_chunks.push(chunk);
                            }
                        }
                        QuestPacketFileType::Dat => {
                            if dat_header.is_none() {
                                return Err(QuestQstError::DataFormatError(String::from("Encountered data chunk packet for dat file before its header packet")));
                            } else {
                                dat_data_counter += chunk.size as usize;
                                dat_chunks.push(chunk);
                            }
                        }
                        QuestPacketFileType::Unknown => {
                            return Err(QuestQstError::DataFormatError(String::from(
                                "Unable to determine file type from filename in data chunk packet",
                            )))
                        }
                    }
                }
                other_id => {
                    return Err(QuestQstError::DataFormatError(format!(
                        "Unexpected packet id found in quest qst data: {}",
                        other_id
                    )))
                }
            }
        }

        let bin_header = bin_header.unwrap();
        let dat_header = dat_header.unwrap();

        // validate that the file bin/dat data chunk byte counts matched what was specified in the
        // bin/dat headers

        if bin_data_counter as u32 != bin_header.size {
            let size = bin_header.size;
            return Err(QuestQstError::DataFormatError(format!(
                "Read {} bytes of bin data, but the bin header specified {} bytes would be present",
                bin_data_counter, size
            )));
        }
        if dat_data_counter as u32 != dat_header.size {
            let size = dat_header.size;
            return Err(QuestQstError::DataFormatError(format!(
                "Read {} bytes of dat data, but the dat header specified {} bytes would be present",
                dat_data_counter, size
            )));
        }

        // validate that all packets encountered (header and data chunk) were of the same category
        // the entire qst file should have only contained packet IDs:
        // - PACKET_ID_QUEST_HEADER_ONLINE and PACKET_ID_QUEST_DATA_ONLINE, or
        // - PACKET_ID_QUEST_HEADER_OFFLINE and PACKET_ID_QUEST_DATA_OFFLINE

        if bin_header.header.id != dat_header.header.id {
            return Err(QuestQstError::DataFormatError(String::from(
                "Packet header ID mismatch between bin and dat headers",
            )));
        }
        let expected_chunk_packets_id = if bin_header.header.id == PACKET_ID_QUEST_HEADER_ONLINE {
            PACKET_ID_QUEST_DATA_ONLINE
        } else {
            PACKET_ID_QUEST_DATA_OFFLINE
        };

        if bin_chunks
            .iter()
            .filter(|chunk| chunk.header.id != expected_chunk_packets_id)
            .count()
            != 0
        {
            return Err(QuestQstError::DataFormatError(format!(
                "One or more bin data chunk packets were not of the expected type: {}",
                expected_chunk_packets_id
            )));
        }
        if dat_chunks
            .iter()
            .filter(|chunk| chunk.header.id != expected_chunk_packets_id)
            .count()
            != 0
        {
            return Err(QuestQstError::DataFormatError(format!(
                "One or more dat data chunk packets were not of the expected type: {}",
                expected_chunk_packets_id
            )));
        }

        Ok(QuestQst {
            bin_header,
            dat_header,
            bin_chunks: bin_chunks.into_boxed_slice(),
            dat_chunks: dat_chunks.into_boxed_slice(),
        })
    }

    pub fn write_bytes<T: WriteBytesExt>(&self, writer: &mut T) -> Result<(), QuestQstError> {
        self.bin_header.write_bytes(writer)?;
        self.dat_header.write_bytes(writer)?;
        for chunk in self.bin_chunks.iter().interleave(self.dat_chunks.iter()) {
            chunk.write_bytes(writer)?;
        }
        Ok(())
    }

    pub fn to_file(&self, path: &Path) -> Result<(), QuestQstError> {
        let mut file = File::create(path)?;
        self.write_bytes(&mut file)?;
        Ok(())
    }

    pub fn to_bytes(&self) -> Result<Box<[u8]>, QuestQstError> {
        let mut buffer = Cursor::new(Vec::<u8>::new());
        self.write_bytes(&mut buffer)?;
        Ok(buffer.into_inner().into_boxed_slice())
    }

    pub fn is_online(&self) -> bool {
        // assumes that a QuestQst could never be created with bin/dat headers containing
        // different packet IDs ...
        self.bin_header.header.id == PACKET_ID_QUEST_HEADER_ONLINE
    }

    pub fn extract_bin_bytes(&self) -> Result<Box<[u8]>, QuestQstError> {
        Ok(extract_quest_chunk_data(&self.bin_chunks, self.is_online())?.into_boxed_slice())
    }

    pub fn extract_bin(&self) -> Result<QuestBin, QuestQstError> {
        let data = self.extract_bin_bytes()?;
        Ok(QuestBin::from_compressed_bytes(data.as_ref())?)
    }

    pub fn extract_dat_bytes(&self) -> Result<Box<[u8]>, QuestQstError> {
        Ok(extract_quest_chunk_data(&self.dat_chunks, self.is_online())?.into_boxed_slice())
    }

    pub fn extract_dat(&self) -> Result<QuestDat, QuestQstError> {
        let data = self.extract_dat_bytes()?;
        Ok(QuestDat::from_compressed_bytes(data.as_ref())?)
    }
}

#[cfg(test)]
mod tests {
    use std::ops::Deref;

    use claim::*;
    use tempfile::TempDir;

    use crate::quest::bin::tests::{validate_quest_118_bin, validate_quest_58_bin};
    use crate::quest::dat::tests::{validate_quest_118_dat, validate_quest_58_dat};

    use super::*;

    fn get_num_chunks_for_size(size: usize) -> usize {
        ((size as f32) / (QUEST_DATA_PACKET_DATA_SIZE as f32)).ceil() as usize
    }

    fn validate_quest_58_qst(
        qst: &QuestQst,
        bin_size: usize,
        dat_size: usize,
        is_online: bool,
    ) -> Result<(), QuestQstError> {
        let (expected_header_id, expected_chunk_id) = if is_online {
            (PACKET_ID_QUEST_HEADER_ONLINE, PACKET_ID_QUEST_DATA_ONLINE)
        } else {
            (PACKET_ID_QUEST_HEADER_OFFLINE, PACKET_ID_QUEST_DATA_OFFLINE)
        };

        assert_eq!(qst.is_online(), is_online);

        assert_eq!(qst.bin_header.header.id, expected_header_id);
        assert_eq!(qst.bin_header.name_str()?, "Lost HEAT SWORD");
        assert_eq!(qst.bin_header.filename_str()?, "quest58.bin");
        assert_eq!(qst.bin_header.file_type(), QuestPacketFileType::Bin);
        let size = qst.bin_header.size as usize;
        assert_eq!(size, bin_size);

        let num_chunks = get_num_chunks_for_size(bin_size);
        assert_eq!(qst.bin_chunks.len(), num_chunks);
        for chunk in qst.bin_chunks.iter() {
            assert_eq!(chunk.header.id, expected_chunk_id);
            assert_eq!(chunk.filename_str()?, "quest58.bin");
            assert_eq!(chunk.file_type(), QuestPacketFileType::Bin);
            assert!(chunk.data().len() > 0);
        }

        assert_eq!(qst.dat_header.header.id, expected_header_id);
        assert_eq!(qst.dat_header.name_str()?, "Lost HEAT SWORD");
        assert_eq!(qst.dat_header.filename_str()?, "quest58.dat");
        assert_eq!(qst.dat_header.file_type(), QuestPacketFileType::Dat);
        let size = qst.dat_header.size as usize;
        assert_eq!(size, dat_size);

        let num_chunks = get_num_chunks_for_size(dat_size);
        assert_eq!(qst.dat_chunks.len(), num_chunks);
        for chunk in qst.dat_chunks.iter() {
            assert_eq!(chunk.header.id, expected_chunk_id);
            assert_eq!(chunk.filename_str()?, "quest58.dat");
            assert_eq!(chunk.file_type(), QuestPacketFileType::Dat);
            assert!(chunk.data().len() > 0);
        }

        let mut bin = qst.extract_bin()?;
        if !is_online {
            assert_eq!(true, bin.header.is_download);
            bin.header.is_download = false;
        }
        validate_quest_58_bin(&bin);

        let dat = qst.extract_dat()?;
        validate_quest_58_dat(&dat);

        Ok(())
    }

    fn validate_quest_118_qst(
        qst: &QuestQst,
        bin_size: usize,
        dat_size: usize,
        is_online: bool,
    ) -> Result<(), QuestQstError> {
        let (expected_header_id, expected_chunk_id) = if is_online {
            (PACKET_ID_QUEST_HEADER_ONLINE, PACKET_ID_QUEST_DATA_ONLINE)
        } else {
            (PACKET_ID_QUEST_HEADER_OFFLINE, PACKET_ID_QUEST_DATA_OFFLINE)
        };

        assert_eq!(qst.is_online(), is_online);

        assert_eq!(qst.bin_header.header.id, expected_header_id);
        assert_eq!(qst.bin_header.name_str()?, "Towards the Future");
        assert_eq!(qst.bin_header.filename_str()?, "quest118.bin");
        assert_eq!(qst.bin_header.file_type(), QuestPacketFileType::Bin);
        let size = qst.bin_header.size as usize;
        assert_eq!(size, bin_size);

        let num_chunks = get_num_chunks_for_size(bin_size);
        assert_eq!(qst.bin_chunks.len(), num_chunks);
        for chunk in qst.bin_chunks.iter() {
            assert_eq!(chunk.header.id, expected_chunk_id);
            assert_eq!(chunk.filename_str()?, "quest118.bin");
            assert_eq!(chunk.file_type(), QuestPacketFileType::Bin);
            assert!(chunk.data().len() > 0);
        }

        assert_eq!(qst.dat_header.header.id, expected_header_id);
        assert_eq!(qst.dat_header.name_str()?, "Towards the Future");
        assert_eq!(qst.dat_header.filename_str()?, "quest118.dat");
        assert_eq!(qst.dat_header.file_type(), QuestPacketFileType::Dat);
        let size = qst.dat_header.size as usize;
        assert_eq!(size, dat_size);

        let num_chunks = get_num_chunks_for_size(dat_size);
        assert_eq!(qst.dat_chunks.len(), num_chunks);
        for chunk in qst.dat_chunks.iter() {
            assert_eq!(chunk.header.id, expected_chunk_id);
            assert_eq!(chunk.filename_str()?, "quest118.dat");
            assert_eq!(chunk.file_type(), QuestPacketFileType::Dat);
            assert!(chunk.data().len() > 0);
        }

        let mut bin = qst.extract_bin()?;
        if !is_online {
            assert_eq!(true, bin.header.is_download);
            bin.header.is_download = false;
        }
        validate_quest_118_bin(&bin);

        let dat = qst.extract_dat()?;
        validate_quest_118_dat(&dat);

        Ok(())
    }

    #[test]
    pub fn read_quest_58_qst_from_file() -> Result<(), QuestQstError> {
        let qst = QuestQst::from_file(Path::new("../test-assets/q058-ret-gc.online.qst"))?;
        validate_quest_58_qst(&qst, 1438, 15097, true)?;

        let qst = QuestQst::from_file(Path::new("../test-assets/q058-ret-gc.offline.qst"))?;
        validate_quest_58_qst(&qst, 1571, 15105, false)?;

        Ok(())
    }

    #[test]
    pub fn write_quest_58_qst_to_file() -> Result<(), QuestQstError> {
        let online_data = include_bytes!("../../../test-assets/q058-ret-gc.online.qst");
        let offline_data = include_bytes!("../../../test-assets/q058-ret-gc.offline.qst");

        let tmp_dir = TempDir::new()?;

        let mut reader = Cursor::new(online_data);
        let qst = QuestQst::from_bytes(&mut reader)?;
        let qst_path = tmp_dir.path().join("quest58.online.qst");
        qst.to_file(&qst_path)?;
        let qst = QuestQst::from_file(&qst_path)?;
        validate_quest_58_qst(&qst, 1438, 15097, true)?;

        let mut reader = Cursor::new(offline_data);
        let qst = QuestQst::from_bytes(&mut reader)?;
        let qst_path = tmp_dir.path().join("quest58.offline.qst");
        qst.to_file(&qst_path)?;
        let qst = QuestQst::from_file(&qst_path)?;
        validate_quest_58_qst(&qst, 1571, 15105, false)?;

        Ok(())
    }

    #[test]
    pub fn read_quest_118_qst_from_file() -> Result<(), QuestQstError> {
        let qst = QuestQst::from_file(Path::new("../test-assets/q118-vr-gc.online.qst"))?;
        validate_quest_118_qst(&qst, 14208, 11802, true)?;

        let qst = QuestQst::from_file(Path::new("../test-assets/q118-vr-gc.offline.qst"))?;
        validate_quest_118_qst(&qst, 14801, 11810, false)?;

        Ok(())
    }

    #[test]
    pub fn write_quest_118_qst_to_file() -> Result<(), QuestQstError> {
        let online_data = include_bytes!("../../../test-assets/q118-vr-gc.online.qst");
        let offline_data = include_bytes!("../../../test-assets/q118-vr-gc.offline.qst");

        let tmp_dir = TempDir::new()?;

        let mut reader = Cursor::new(online_data);
        let qst = QuestQst::from_bytes(&mut reader)?;
        let qst_path = tmp_dir.path().join("quest118.online.qst");
        qst.to_file(&qst_path)?;
        let qst = QuestQst::from_file(&qst_path)?;
        validate_quest_118_qst(&qst, 14208, 11802, true)?;

        let mut reader = Cursor::new(offline_data);
        let qst = QuestQst::from_bytes(&mut reader)?;
        let qst_path = tmp_dir.path().join("quest118.offline.qst");
        qst.to_file(&qst_path)?;
        let qst = QuestQst::from_file(&qst_path)?;
        validate_quest_118_qst(&qst, 14801, 11810, false)?;

        Ok(())
    }

    #[test]
    pub fn create_qst_from_quest_58_bindat_files() -> Result<(), QuestQstError> {
        let mut bin = QuestBin::from_compressed_file(Path::new("../test-assets/q058-ret-gc.bin"))?;
        let dat = QuestDat::from_compressed_file(Path::new("../test-assets/q058-ret-gc.dat"))?;

        let qst = QuestQst::from_bindat(&bin, &dat)?;
        validate_quest_58_qst(&qst, 1565, 15507, true)?;

        bin.header.is_download = true;
        let qst = QuestQst::from_bindat(&bin, &dat)?;
        validate_quest_58_qst(&qst, 1573, 15515, false)?;

        Ok(())
    }

    #[test]
    pub fn create_qst_from_quest_118_bindat_files() -> Result<(), QuestQstError> {
        let mut bin = QuestBin::from_compressed_file(Path::new("../test-assets/q118-vr-gc.bin"))?;
        let dat = QuestDat::from_compressed_file(Path::new("../test-assets/q118-vr-gc.dat"))?;

        let qst = QuestQst::from_bindat(&bin, &dat)?;
        validate_quest_118_qst(&qst, 14794, 12277, true)?;

        bin.header.is_download = true;
        let qst = QuestQst::from_bindat(&bin, &dat)?;
        validate_quest_118_qst(&qst, 14803, 12285, false)?;

        Ok(())
    }

    #[test]
    pub fn error_on_load_from_zero_bytes() {
        let mut data: &[u8] = &[];
        assert_matches!(
            QuestQst::from_bytes(&mut data),
            Err(QuestQstError::DataPacketError(..))
        );
    }

    #[test]
    pub fn error_on_load_from_garbage_bytes() {
        let mut data: &[u8] = b"This is definitely not a quest";
        assert_matches!(
            QuestQst::from_bytes(&mut data),
            Err(QuestQstError::DataFormatError(..))
        );
    }

    #[test]
    pub fn error_on_bad_packet_id_encountered() {
        // packet header bytes with bad packet id
        let mut data: &[u8] = &[0x42, 0x00, 0x3C, 0x00];
        assert_matches!(
            QuestQst::from_bytes(&mut data),
            Err(QuestQstError::DataFormatError(..))
        );
    }

    #[test]
    pub fn error_on_bad_packet_size_encountered() {
        // packet header bytes for a QuestHeaderPacket, but with the wrong packet size
        let mut data: &[u8] = &[0x44, 0x00, 0x3C, 0x11];
        assert_matches!(
            QuestQst::from_bytes(&mut data),
            Err(QuestQstError::DataPacketError(PacketError::WrongSize(..)))
        );
    }

    #[test]
    pub fn error_on_header_packet_with_non_bin_or_dat_filename() {
        // an otherwise valid QuestHeaderPacket, but with a filename that cannot be recognized
        // as a .bin or .dat file type
        let mut data: &[u8] = &[
            0xA6, 0x00, 0x3C, 0x00, 0x4C, 0x6F, 0x73, 0x74, 0x20, 0x48, 0x45, 0x41, 0x54, 0x20,
            0x53, 0x57, 0x4F, 0x52, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x71, 0x75,
            0x65, 0x73, 0x74, 0x35, 0x38, 0x2E, 0x78, 0x79, 0x7A, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x23, 0x06, 0x00, 0x00,
        ];
        assert_matches!(
            QuestQst::from_bytes(&mut data),
            Err(QuestQstError::DataFormatError(..))
        );
    }

    #[test]
    pub fn error_on_header_packet_with_missing_filename() {
        // an otherwise valid QuestHeaderPacket, but with a missing filename (all null bytes)
        let mut data: &[u8] = &[
            0xA6, 0x00, 0x3C, 0x00, 0x4C, 0x6F, 0x73, 0x74, 0x20, 0x48, 0x45, 0x41, 0x54, 0x20,
            0x53, 0x57, 0x4F, 0x52, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x23, 0x06, 0x00, 0x00,
        ];
        assert_matches!(
            QuestQst::from_bytes(&mut data),
            Err(QuestQstError::DataFormatError(..))
        );
    }

    #[test]
    pub fn error_on_duplicate_header_packet() {
        // two QuestHeaderPackets in a row, both for the .dat file
        let mut data: &[u8] = &[
            0xA6, 0x00, 0x3C, 0x00, 0x4C, 0x6F, 0x73, 0x74, 0x20, 0x48, 0x45, 0x41, 0x54, 0x20,
            0x53, 0x57, 0x4F, 0x52, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x71, 0x75,
            0x65, 0x73, 0x74, 0x35, 0x38, 0x2E, 0x64, 0x61, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x01, 0x3B, 0x00, 0x00, 0xA6, 0x00, 0x3C, 0x00, 0x4C, 0x6F, 0x73, 0x74, 0x20, 0x48,
            0x45, 0x41, 0x54, 0x20, 0x53, 0x57, 0x4F, 0x52, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x71, 0x75, 0x65, 0x73, 0x74, 0x35, 0x38, 0x2E, 0x64, 0x61, 0x74, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x01, 0x3B, 0x00, 0x00,
        ];
        assert_matches!(
            QuestQst::from_bytes(&mut data),
            Err(QuestQstError::DataFormatError(..))
        );
    }

    #[test]
    pub fn error_on_data_packet_before_header_packet() {
        // packet header bytes for a QuestDataPacket, fails because we expect to find a
        // QuestHeaderPacket before any data packets
        let mut data: &[u8] = &[0xA7, 0x00, 0x12, 0x34];
        assert_matches!(
            QuestQst::from_bytes(&mut data),
            Err(QuestQstError::DataFormatError(..))
        );
    }

    #[test]
    pub fn error_on_data_packet_with_non_bin_or_dat_filename() {
        // header is fine
        let header: &[u8] = &[
            0xA6, 0x00, 0x3C, 0x00, 0x4C, 0x6F, 0x73, 0x74, 0x20, 0x48, 0x45, 0x41, 0x54, 0x20,
            0x53, 0x57, 0x4F, 0x52, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x71, 0x75,
            0x65, 0x73, 0x74, 0x35, 0x38, 0x2E, 0x62, 0x69, 0x6E, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x23, 0x06, 0x00, 0x00,
        ];
        // data chunk packet has non .bin or .dat filename (but is otherwise fine)
        let data_chunk: &[u8] = &[
            0xA7, 0x00, 0x18, 0x04, 0x71, 0x75, 0x65, 0x73, 0x74, 0x35, 0x38, 0x2E, 0x66, 0x6F,
            0x6F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0x19, 0x00, 0x00, 0x86, 0xF9, 0xD3, 0x12,
            0xF5, 0xDA, 0x71, 0xBA, 0x23, 0x5A, 0x97, 0x42, 0x6A, 0xFC, 0xB0, 0x9E, 0x73, 0x0F,
            0xFC, 0xCF, 0x61, 0x21, 0xF0, 0x92, 0x6F, 0xDF, 0x25, 0x33, 0x17, 0x9E, 0x7C, 0x75,
            0x7B, 0x21, 0xC3, 0x5F, 0xD2, 0x8C, 0x03, 0x9F, 0x67, 0x60, 0x94, 0x6E, 0x25, 0xE5,
            0x26, 0x25, 0x6C, 0xB4, 0x39, 0xF4, 0xBF, 0xDF, 0x76, 0x6A, 0x07, 0x6B, 0x81, 0xD0,
            0x18, 0x4D, 0xF9, 0xE8, 0xAE, 0x59, 0x0E, 0x56, 0x5B, 0x4A, 0x4D, 0x0F, 0x11, 0x27,
            0xD7, 0xBD, 0xA0, 0xAE, 0xCE, 0x14, 0x9E, 0xB2, 0x88, 0x57, 0x3B, 0xCB, 0xA1, 0xB5,
            0x0D, 0xEB, 0x44, 0x4D, 0x13, 0x8B, 0x89, 0x9C, 0x80, 0x6F, 0xF0, 0x25, 0x2C, 0xAC,
            0x20, 0xDA, 0x65, 0x78, 0x93, 0x02, 0x75, 0x41, 0xFC, 0xDD, 0xFD, 0xAB, 0x5B, 0xD9,
            0x78, 0xA9, 0x09, 0xA6, 0xFE, 0xD2, 0x52, 0xFC, 0x4A, 0x66, 0x90, 0xB4, 0xDF, 0xD7,
            0x34, 0x4A, 0xD4, 0x3C, 0xE8, 0xA3, 0x0B, 0xB4, 0xFD, 0xE3, 0x34, 0x6C, 0x49, 0x85,
            0xF4, 0xAE, 0xB9, 0x55, 0x6B, 0x3E, 0x4B, 0x82, 0xCF, 0x5B, 0x22, 0x3A, 0x92, 0xA3,
            0x0F, 0xB7, 0xBE, 0x71, 0x59, 0xCC, 0xE7, 0xDA, 0xDB, 0x69, 0x77, 0xC7, 0x63, 0x44,
            0x8E, 0xC4, 0xF7, 0xE2, 0x5F, 0xA4, 0xAB, 0x5D, 0x7A, 0x21, 0xD7, 0x1F, 0xAD, 0x58,
            0xAD, 0x66, 0x3E, 0x4A, 0x00, 0x93, 0xA2, 0x0A, 0xCD, 0xB4, 0x96, 0x1A, 0xF0, 0x72,
            0xD0, 0xEB, 0xF1, 0x89, 0x16, 0xFF, 0x11, 0x66, 0x5A, 0xF0, 0x63, 0xB8, 0x56, 0x09,
            0x99, 0xCE, 0x66, 0x6B, 0x7C, 0xE5, 0xE7, 0xE1, 0x2E, 0xC4, 0xEA, 0xA5, 0x43, 0x82,
            0x82, 0xAE, 0x49, 0x3E, 0xF1, 0x5F, 0x1C, 0xBB, 0xD1, 0x5B, 0x79, 0xBA, 0xE1, 0xF8,
            0x68, 0x6C, 0xB1, 0x39, 0x01, 0xAA, 0xCE, 0x4F, 0xE8, 0x90, 0x84, 0xD9, 0xEE, 0x99,
            0xE1, 0x60, 0xD8, 0x1D, 0xE8, 0x80, 0xF5, 0x34, 0x75, 0x07, 0xAB, 0x60, 0x94, 0x9B,
            0x91, 0x45, 0xF5, 0xD6, 0xF5, 0x32, 0x29, 0xD8, 0xAE, 0xD7, 0xE6, 0x58, 0x02, 0x87,
            0x44, 0xF7, 0x46, 0xCC, 0x28, 0x38, 0xBF, 0x1C, 0x9C, 0x5B, 0xF7, 0x88, 0x46, 0x85,
            0x1D, 0x0A, 0x9E, 0xEC, 0xBE, 0x34, 0x20, 0xD6, 0xCD, 0x80, 0xF5, 0x72, 0xDD, 0x17,
            0x96, 0x40, 0x5D, 0x8A, 0x52, 0xD3, 0x2E, 0x9B, 0x8B, 0xDD, 0x59, 0xC4, 0x90, 0x3C,
            0x1A, 0x44, 0x33, 0x58, 0x5C, 0xE1, 0x6F, 0xDF, 0x9D, 0xFF, 0xFC, 0x6E, 0xF3, 0x0C,
            0x7F, 0xBE, 0x3F, 0x3F, 0x41, 0xBA, 0xD9, 0xFB, 0x93, 0x08, 0x4B, 0xB0, 0x29, 0x58,
            0x95, 0xB5, 0x28, 0xE4, 0xED, 0x5A, 0x97, 0xBE, 0xDD, 0x15, 0xCB, 0xCE, 0x41, 0x11,
            0xBE, 0x86, 0x52, 0xED, 0x90, 0x0F, 0x7C, 0x62, 0xE8, 0x24, 0x63, 0x5B, 0x48, 0x6B,
            0x37, 0xEA, 0x59, 0xE9, 0xD2, 0x18, 0xD4, 0x3D, 0xA7, 0x5F, 0x96, 0x36, 0xED, 0x6F,
            0xC6, 0x30, 0x06, 0x4E, 0x96, 0xB8, 0x5D, 0x3A, 0x14, 0xBC, 0xD5, 0x4A, 0x8D, 0x0C,
            0x6C, 0xB2, 0x7B, 0x54, 0xA8, 0x81, 0xB1, 0x2E, 0x05, 0x46, 0xE7, 0x45, 0x54, 0x7E,
            0x3C, 0x0D, 0x30, 0x79, 0x3E, 0xE9, 0xB1, 0xD4, 0xB5, 0xD7, 0x83, 0x27, 0xE6, 0x83,
            0x08, 0xDD, 0x43, 0xA1, 0xA5, 0xDE, 0xD7, 0xC7, 0xDC, 0xB2, 0x99, 0xC4, 0x76, 0x20,
            0xB6, 0xDB, 0xA9, 0x4C, 0x96, 0x22, 0x2D, 0xEC, 0xBE, 0x01, 0x33, 0xAB, 0xC4, 0x63,
            0xE6, 0x54, 0xDD, 0x55, 0x66, 0xEB, 0xAF, 0xAD, 0x1D, 0xA4, 0x77, 0x18, 0x03, 0xD4,
            0xCF, 0x16, 0x8F, 0x0F, 0xD7, 0x5A, 0x19, 0xDB, 0xE6, 0xB5, 0xE1, 0x8E, 0x76, 0xF8,
            0x86, 0x1C, 0x24, 0x17, 0xD4, 0x4B, 0xDA, 0x63, 0x87, 0x94, 0x4E, 0x8E, 0x85, 0x7A,
            0x60, 0xC0, 0xF4, 0xBA, 0x04, 0x27, 0x3A, 0x31, 0x20, 0xDB, 0x8C, 0x54, 0x92, 0xFE,
            0x38, 0x92, 0xFA, 0x6D, 0xD9, 0x4B, 0xBA, 0x1E, 0xED, 0x8A, 0xEC, 0x92, 0xD7, 0x76,
            0x0B, 0x7C, 0x6B, 0x75, 0xFF, 0xFA, 0xE1, 0x53, 0x0F, 0xA6, 0x98, 0x3E, 0x74, 0xD9,
            0x04, 0xEF, 0x5C, 0xD7, 0xF9, 0xBF, 0x5C, 0x87, 0xD8, 0x7E, 0xF4, 0xDB, 0xFB, 0xAC,
            0xD2, 0xA1, 0xEA, 0x9F, 0x00, 0xB3, 0xD1, 0x28, 0xE7, 0xEC, 0xD7, 0xDA, 0x42, 0x43,
            0x70, 0x0F, 0x49, 0xC5, 0xF0, 0xFE, 0xD2, 0xE4, 0xEF, 0xA6, 0xA7, 0xE0, 0x36, 0x38,
            0x8B, 0x27, 0x1D, 0x42, 0x83, 0xC5, 0x3A, 0xD2, 0x85, 0x1B, 0xB1, 0xBD, 0xE1, 0x9C,
            0x20, 0x35, 0x65, 0x40, 0x41, 0x9E, 0xF7, 0x01, 0x34, 0x0F, 0xC9, 0xE0, 0xCC, 0x5D,
            0x94, 0xD9, 0xD4, 0x17, 0x45, 0xFC, 0x10, 0x77, 0x56, 0x48, 0x2A, 0xA5, 0x91, 0x6A,
            0x2E, 0x3B, 0xED, 0xCF, 0x2C, 0xB0, 0xE5, 0x46, 0x71, 0x7E, 0x87, 0xB6, 0x5F, 0xA4,
            0x6F, 0xE9, 0x68, 0xA7, 0x9E, 0x83, 0x22, 0x25, 0x18, 0x7D, 0x13, 0xE7, 0xB1, 0x60,
            0x0A, 0xAB, 0x2D, 0x24, 0xA7, 0x2F, 0xB3, 0xFE, 0x09, 0xDC, 0x46, 0x9F, 0xAA, 0x00,
            0x0A, 0xB1, 0x3D, 0x6E, 0x5C, 0x6D, 0x61, 0xED, 0x35, 0x96, 0xB8, 0x0F, 0xE3, 0xCF,
            0x33, 0x99, 0xA1, 0x6B, 0x8B, 0x92, 0x66, 0x5F, 0xEC, 0xFB, 0xD0, 0x22, 0x24, 0x01,
            0x10, 0x1E, 0xAF, 0x16, 0x38, 0x0A, 0x5C, 0xB9, 0xCC, 0x06, 0xCE, 0xCE, 0x5C, 0x20,
            0xF4, 0xC0, 0xCB, 0x34, 0x09, 0x23, 0xE9, 0x14, 0x2F, 0x19, 0x98, 0x4A, 0xC1, 0xE0,
            0x55, 0xDF, 0xD7, 0xBF, 0x68, 0xEE, 0x14, 0xB0, 0xFE, 0x88, 0x97, 0xFC, 0x79, 0x36,
            0x23, 0xA2, 0x2D, 0xB1, 0xC9, 0x0F, 0x2C, 0x32, 0x4E, 0x8C, 0x39, 0x47, 0x51, 0xD5,
            0xCD, 0x8D, 0x23, 0x73, 0xFC, 0x56, 0xAB, 0x81, 0x5D, 0x23, 0xEF, 0xF4, 0x9B, 0x19,
            0x08, 0xD4, 0xB9, 0x1C, 0x12, 0x44, 0x8A, 0xBD, 0x4F, 0x4B, 0x9B, 0xD7, 0x4C, 0xBA,
            0x1B, 0x8A, 0x08, 0x05, 0xA1, 0xF5, 0xEE, 0x55, 0x03, 0x2B, 0xAA, 0x71, 0x4D, 0x51,
            0x6F, 0xF8, 0xC6, 0xBC, 0x28, 0x07, 0x53, 0xB5, 0x07, 0xC3, 0x00, 0x12, 0x64, 0x05,
            0x63, 0x6E, 0xC1, 0x13, 0xDD, 0x1E, 0xDB, 0x04, 0x29, 0x1D, 0xC8, 0xBB, 0xE3, 0x11,
            0x05, 0x21, 0xF0, 0xD8, 0x50, 0x12, 0x04, 0xC0, 0x92, 0x6B, 0x0B, 0x35, 0x0D, 0xEC,
            0xD3, 0x38, 0x09, 0xC7, 0x8A, 0x25, 0xFB, 0x66, 0xCC, 0xD9, 0x89, 0xDA, 0x9E, 0x48,
            0x08, 0x3A, 0xF4, 0xDD, 0x48, 0x1F, 0x46, 0x0E, 0x64, 0xCE, 0x84, 0x21, 0x62, 0xD4,
            0x3F, 0x32, 0xEC, 0x41, 0xF7, 0x29, 0xC3, 0xB4, 0xEF, 0x90, 0xFD, 0x80, 0x42, 0x1A,
            0x8E, 0xF9, 0xEE, 0x64, 0xE5, 0x18, 0xD1, 0xA8, 0x39, 0xBF, 0x59, 0x9D, 0xD7, 0x4B,
            0xA2, 0x96, 0xED, 0x7A, 0xF2, 0x23, 0x3B, 0xA7, 0xD6, 0xEA, 0xEF, 0x08, 0xAD, 0x61,
            0x67, 0x8A, 0x55, 0x51, 0x03, 0x2D, 0xBE, 0x1A, 0x61, 0xBE, 0xC8, 0x8F, 0xEE, 0x99,
            0x8B, 0x7B, 0xD6, 0x80, 0xFB, 0xBE, 0x1C, 0xC2, 0xE5, 0xC0, 0x4E, 0x5C, 0xC9, 0x95,
            0x20, 0xEA, 0x68, 0xF1, 0xF8, 0xFA, 0x1E, 0x4F, 0x2B, 0xC8, 0x11, 0x79, 0x18, 0xDD,
            0x9A, 0x9E, 0x23, 0x58, 0x05, 0xE1, 0xC3, 0x12, 0xF3, 0xB3, 0x41, 0xD0, 0xAD, 0xED,
            0x4C, 0xE0, 0x9E, 0xBC, 0xB9, 0x70, 0xF2, 0xAB, 0xA4, 0x18, 0xD5, 0xAB, 0xAB, 0x8C,
            0x65, 0xBE, 0x86, 0x62, 0x7C, 0xB2, 0xFF, 0xDD, 0x17, 0xDA, 0x3C, 0xD1, 0x91, 0x7D,
            0x01, 0x8A, 0x6A, 0xA3, 0x45, 0x06, 0x11, 0xE8, 0xA4, 0x01, 0x48, 0xF7, 0xC1, 0xB2,
            0x4A, 0xE5, 0x98, 0xCC, 0xCC, 0xB2, 0xFF, 0x9A, 0x00, 0x04, 0x00, 0x00,
        ];
        let data = [header, data_chunk].concat();
        assert_matches!(
            QuestQst::from_bytes(&mut data.as_slice()),
            Err(QuestQstError::DataFormatError(..))
        );
    }

    #[test]
    pub fn error_on_data_packet_with_missing_filename() {
        // header is fine
        let header: &[u8] = &[
            0xA6, 0x00, 0x3C, 0x00, 0x4C, 0x6F, 0x73, 0x74, 0x20, 0x48, 0x45, 0x41, 0x54, 0x20,
            0x53, 0x57, 0x4F, 0x52, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x71, 0x75,
            0x65, 0x73, 0x74, 0x35, 0x38, 0x2E, 0x62, 0x69, 0x6E, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x23, 0x06, 0x00, 0x00,
        ];
        // data chunk packet has no filename (all null bytes)
        let data_chunk: &[u8] = &[
            0xA7, 0x00, 0x18, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0x19, 0x00, 0x00, 0x86, 0xF9, 0xD3, 0x12,
            0xF5, 0xDA, 0x71, 0xBA, 0x23, 0x5A, 0x97, 0x42, 0x6A, 0xFC, 0xB0, 0x9E, 0x73, 0x0F,
            0xFC, 0xCF, 0x61, 0x21, 0xF0, 0x92, 0x6F, 0xDF, 0x25, 0x33, 0x17, 0x9E, 0x7C, 0x75,
            0x7B, 0x21, 0xC3, 0x5F, 0xD2, 0x8C, 0x03, 0x9F, 0x67, 0x60, 0x94, 0x6E, 0x25, 0xE5,
            0x26, 0x25, 0x6C, 0xB4, 0x39, 0xF4, 0xBF, 0xDF, 0x76, 0x6A, 0x07, 0x6B, 0x81, 0xD0,
            0x18, 0x4D, 0xF9, 0xE8, 0xAE, 0x59, 0x0E, 0x56, 0x5B, 0x4A, 0x4D, 0x0F, 0x11, 0x27,
            0xD7, 0xBD, 0xA0, 0xAE, 0xCE, 0x14, 0x9E, 0xB2, 0x88, 0x57, 0x3B, 0xCB, 0xA1, 0xB5,
            0x0D, 0xEB, 0x44, 0x4D, 0x13, 0x8B, 0x89, 0x9C, 0x80, 0x6F, 0xF0, 0x25, 0x2C, 0xAC,
            0x20, 0xDA, 0x65, 0x78, 0x93, 0x02, 0x75, 0x41, 0xFC, 0xDD, 0xFD, 0xAB, 0x5B, 0xD9,
            0x78, 0xA9, 0x09, 0xA6, 0xFE, 0xD2, 0x52, 0xFC, 0x4A, 0x66, 0x90, 0xB4, 0xDF, 0xD7,
            0x34, 0x4A, 0xD4, 0x3C, 0xE8, 0xA3, 0x0B, 0xB4, 0xFD, 0xE3, 0x34, 0x6C, 0x49, 0x85,
            0xF4, 0xAE, 0xB9, 0x55, 0x6B, 0x3E, 0x4B, 0x82, 0xCF, 0x5B, 0x22, 0x3A, 0x92, 0xA3,
            0x0F, 0xB7, 0xBE, 0x71, 0x59, 0xCC, 0xE7, 0xDA, 0xDB, 0x69, 0x77, 0xC7, 0x63, 0x44,
            0x8E, 0xC4, 0xF7, 0xE2, 0x5F, 0xA4, 0xAB, 0x5D, 0x7A, 0x21, 0xD7, 0x1F, 0xAD, 0x58,
            0xAD, 0x66, 0x3E, 0x4A, 0x00, 0x93, 0xA2, 0x0A, 0xCD, 0xB4, 0x96, 0x1A, 0xF0, 0x72,
            0xD0, 0xEB, 0xF1, 0x89, 0x16, 0xFF, 0x11, 0x66, 0x5A, 0xF0, 0x63, 0xB8, 0x56, 0x09,
            0x99, 0xCE, 0x66, 0x6B, 0x7C, 0xE5, 0xE7, 0xE1, 0x2E, 0xC4, 0xEA, 0xA5, 0x43, 0x82,
            0x82, 0xAE, 0x49, 0x3E, 0xF1, 0x5F, 0x1C, 0xBB, 0xD1, 0x5B, 0x79, 0xBA, 0xE1, 0xF8,
            0x68, 0x6C, 0xB1, 0x39, 0x01, 0xAA, 0xCE, 0x4F, 0xE8, 0x90, 0x84, 0xD9, 0xEE, 0x99,
            0xE1, 0x60, 0xD8, 0x1D, 0xE8, 0x80, 0xF5, 0x34, 0x75, 0x07, 0xAB, 0x60, 0x94, 0x9B,
            0x91, 0x45, 0xF5, 0xD6, 0xF5, 0x32, 0x29, 0xD8, 0xAE, 0xD7, 0xE6, 0x58, 0x02, 0x87,
            0x44, 0xF7, 0x46, 0xCC, 0x28, 0x38, 0xBF, 0x1C, 0x9C, 0x5B, 0xF7, 0x88, 0x46, 0x85,
            0x1D, 0x0A, 0x9E, 0xEC, 0xBE, 0x34, 0x20, 0xD6, 0xCD, 0x80, 0xF5, 0x72, 0xDD, 0x17,
            0x96, 0x40, 0x5D, 0x8A, 0x52, 0xD3, 0x2E, 0x9B, 0x8B, 0xDD, 0x59, 0xC4, 0x90, 0x3C,
            0x1A, 0x44, 0x33, 0x58, 0x5C, 0xE1, 0x6F, 0xDF, 0x9D, 0xFF, 0xFC, 0x6E, 0xF3, 0x0C,
            0x7F, 0xBE, 0x3F, 0x3F, 0x41, 0xBA, 0xD9, 0xFB, 0x93, 0x08, 0x4B, 0xB0, 0x29, 0x58,
            0x95, 0xB5, 0x28, 0xE4, 0xED, 0x5A, 0x97, 0xBE, 0xDD, 0x15, 0xCB, 0xCE, 0x41, 0x11,
            0xBE, 0x86, 0x52, 0xED, 0x90, 0x0F, 0x7C, 0x62, 0xE8, 0x24, 0x63, 0x5B, 0x48, 0x6B,
            0x37, 0xEA, 0x59, 0xE9, 0xD2, 0x18, 0xD4, 0x3D, 0xA7, 0x5F, 0x96, 0x36, 0xED, 0x6F,
            0xC6, 0x30, 0x06, 0x4E, 0x96, 0xB8, 0x5D, 0x3A, 0x14, 0xBC, 0xD5, 0x4A, 0x8D, 0x0C,
            0x6C, 0xB2, 0x7B, 0x54, 0xA8, 0x81, 0xB1, 0x2E, 0x05, 0x46, 0xE7, 0x45, 0x54, 0x7E,
            0x3C, 0x0D, 0x30, 0x79, 0x3E, 0xE9, 0xB1, 0xD4, 0xB5, 0xD7, 0x83, 0x27, 0xE6, 0x83,
            0x08, 0xDD, 0x43, 0xA1, 0xA5, 0xDE, 0xD7, 0xC7, 0xDC, 0xB2, 0x99, 0xC4, 0x76, 0x20,
            0xB6, 0xDB, 0xA9, 0x4C, 0x96, 0x22, 0x2D, 0xEC, 0xBE, 0x01, 0x33, 0xAB, 0xC4, 0x63,
            0xE6, 0x54, 0xDD, 0x55, 0x66, 0xEB, 0xAF, 0xAD, 0x1D, 0xA4, 0x77, 0x18, 0x03, 0xD4,
            0xCF, 0x16, 0x8F, 0x0F, 0xD7, 0x5A, 0x19, 0xDB, 0xE6, 0xB5, 0xE1, 0x8E, 0x76, 0xF8,
            0x86, 0x1C, 0x24, 0x17, 0xD4, 0x4B, 0xDA, 0x63, 0x87, 0x94, 0x4E, 0x8E, 0x85, 0x7A,
            0x60, 0xC0, 0xF4, 0xBA, 0x04, 0x27, 0x3A, 0x31, 0x20, 0xDB, 0x8C, 0x54, 0x92, 0xFE,
            0x38, 0x92, 0xFA, 0x6D, 0xD9, 0x4B, 0xBA, 0x1E, 0xED, 0x8A, 0xEC, 0x92, 0xD7, 0x76,
            0x0B, 0x7C, 0x6B, 0x75, 0xFF, 0xFA, 0xE1, 0x53, 0x0F, 0xA6, 0x98, 0x3E, 0x74, 0xD9,
            0x04, 0xEF, 0x5C, 0xD7, 0xF9, 0xBF, 0x5C, 0x87, 0xD8, 0x7E, 0xF4, 0xDB, 0xFB, 0xAC,
            0xD2, 0xA1, 0xEA, 0x9F, 0x00, 0xB3, 0xD1, 0x28, 0xE7, 0xEC, 0xD7, 0xDA, 0x42, 0x43,
            0x70, 0x0F, 0x49, 0xC5, 0xF0, 0xFE, 0xD2, 0xE4, 0xEF, 0xA6, 0xA7, 0xE0, 0x36, 0x38,
            0x8B, 0x27, 0x1D, 0x42, 0x83, 0xC5, 0x3A, 0xD2, 0x85, 0x1B, 0xB1, 0xBD, 0xE1, 0x9C,
            0x20, 0x35, 0x65, 0x40, 0x41, 0x9E, 0xF7, 0x01, 0x34, 0x0F, 0xC9, 0xE0, 0xCC, 0x5D,
            0x94, 0xD9, 0xD4, 0x17, 0x45, 0xFC, 0x10, 0x77, 0x56, 0x48, 0x2A, 0xA5, 0x91, 0x6A,
            0x2E, 0x3B, 0xED, 0xCF, 0x2C, 0xB0, 0xE5, 0x46, 0x71, 0x7E, 0x87, 0xB6, 0x5F, 0xA4,
            0x6F, 0xE9, 0x68, 0xA7, 0x9E, 0x83, 0x22, 0x25, 0x18, 0x7D, 0x13, 0xE7, 0xB1, 0x60,
            0x0A, 0xAB, 0x2D, 0x24, 0xA7, 0x2F, 0xB3, 0xFE, 0x09, 0xDC, 0x46, 0x9F, 0xAA, 0x00,
            0x0A, 0xB1, 0x3D, 0x6E, 0x5C, 0x6D, 0x61, 0xED, 0x35, 0x96, 0xB8, 0x0F, 0xE3, 0xCF,
            0x33, 0x99, 0xA1, 0x6B, 0x8B, 0x92, 0x66, 0x5F, 0xEC, 0xFB, 0xD0, 0x22, 0x24, 0x01,
            0x10, 0x1E, 0xAF, 0x16, 0x38, 0x0A, 0x5C, 0xB9, 0xCC, 0x06, 0xCE, 0xCE, 0x5C, 0x20,
            0xF4, 0xC0, 0xCB, 0x34, 0x09, 0x23, 0xE9, 0x14, 0x2F, 0x19, 0x98, 0x4A, 0xC1, 0xE0,
            0x55, 0xDF, 0xD7, 0xBF, 0x68, 0xEE, 0x14, 0xB0, 0xFE, 0x88, 0x97, 0xFC, 0x79, 0x36,
            0x23, 0xA2, 0x2D, 0xB1, 0xC9, 0x0F, 0x2C, 0x32, 0x4E, 0x8C, 0x39, 0x47, 0x51, 0xD5,
            0xCD, 0x8D, 0x23, 0x73, 0xFC, 0x56, 0xAB, 0x81, 0x5D, 0x23, 0xEF, 0xF4, 0x9B, 0x19,
            0x08, 0xD4, 0xB9, 0x1C, 0x12, 0x44, 0x8A, 0xBD, 0x4F, 0x4B, 0x9B, 0xD7, 0x4C, 0xBA,
            0x1B, 0x8A, 0x08, 0x05, 0xA1, 0xF5, 0xEE, 0x55, 0x03, 0x2B, 0xAA, 0x71, 0x4D, 0x51,
            0x6F, 0xF8, 0xC6, 0xBC, 0x28, 0x07, 0x53, 0xB5, 0x07, 0xC3, 0x00, 0x12, 0x64, 0x05,
            0x63, 0x6E, 0xC1, 0x13, 0xDD, 0x1E, 0xDB, 0x04, 0x29, 0x1D, 0xC8, 0xBB, 0xE3, 0x11,
            0x05, 0x21, 0xF0, 0xD8, 0x50, 0x12, 0x04, 0xC0, 0x92, 0x6B, 0x0B, 0x35, 0x0D, 0xEC,
            0xD3, 0x38, 0x09, 0xC7, 0x8A, 0x25, 0xFB, 0x66, 0xCC, 0xD9, 0x89, 0xDA, 0x9E, 0x48,
            0x08, 0x3A, 0xF4, 0xDD, 0x48, 0x1F, 0x46, 0x0E, 0x64, 0xCE, 0x84, 0x21, 0x62, 0xD4,
            0x3F, 0x32, 0xEC, 0x41, 0xF7, 0x29, 0xC3, 0xB4, 0xEF, 0x90, 0xFD, 0x80, 0x42, 0x1A,
            0x8E, 0xF9, 0xEE, 0x64, 0xE5, 0x18, 0xD1, 0xA8, 0x39, 0xBF, 0x59, 0x9D, 0xD7, 0x4B,
            0xA2, 0x96, 0xED, 0x7A, 0xF2, 0x23, 0x3B, 0xA7, 0xD6, 0xEA, 0xEF, 0x08, 0xAD, 0x61,
            0x67, 0x8A, 0x55, 0x51, 0x03, 0x2D, 0xBE, 0x1A, 0x61, 0xBE, 0xC8, 0x8F, 0xEE, 0x99,
            0x8B, 0x7B, 0xD6, 0x80, 0xFB, 0xBE, 0x1C, 0xC2, 0xE5, 0xC0, 0x4E, 0x5C, 0xC9, 0x95,
            0x20, 0xEA, 0x68, 0xF1, 0xF8, 0xFA, 0x1E, 0x4F, 0x2B, 0xC8, 0x11, 0x79, 0x18, 0xDD,
            0x9A, 0x9E, 0x23, 0x58, 0x05, 0xE1, 0xC3, 0x12, 0xF3, 0xB3, 0x41, 0xD0, 0xAD, 0xED,
            0x4C, 0xE0, 0x9E, 0xBC, 0xB9, 0x70, 0xF2, 0xAB, 0xA4, 0x18, 0xD5, 0xAB, 0xAB, 0x8C,
            0x65, 0xBE, 0x86, 0x62, 0x7C, 0xB2, 0xFF, 0xDD, 0x17, 0xDA, 0x3C, 0xD1, 0x91, 0x7D,
            0x01, 0x8A, 0x6A, 0xA3, 0x45, 0x06, 0x11, 0xE8, 0xA4, 0x01, 0x48, 0xF7, 0xC1, 0xB2,
            0x4A, 0xE5, 0x98, 0xCC, 0xCC, 0xB2, 0xFF, 0x9A, 0x00, 0x04, 0x00, 0x00,
        ];
        let data = [header, data_chunk].concat();
        assert_matches!(
            QuestQst::from_bytes(&mut data.as_slice()),
            Err(QuestQstError::DataFormatError(..))
        );
    }

    #[test]
    pub fn error_when_qst_does_not_contain_both_bin_and_dat_packets() {
        let qst = QuestQst::from_file(Path::new("../test-assets/q058-ret-gc.online.qst")).unwrap();
        // write only the bin header+data packets into a buffer which we will then read a qst from
        let mut bytes = Cursor::new(Vec::new());
        qst.bin_header.write_bytes(&mut bytes).unwrap();
        for chunk in qst.bin_chunks.iter() {
            chunk.write_bytes(&mut bytes).unwrap();
        }
        // this will fail because from_bytes loops infinitely until both a bin and dat are fully
        // read. it will reach eof on the buffer once all the bin data is read
        assert_matches!(
            QuestQst::from_bytes(&mut bytes),
            Err(QuestQstError::DataPacketError(PacketError::IoError(..)))
        );
    }

    #[test]
    pub fn error_when_qst_header_packet_ids_do_not_all_match() {
        let qst = QuestQst::from_file(Path::new("../test-assets/q058-ret-gc.online.qst")).unwrap();
        let mut bytes = qst.to_bytes().unwrap();

        // packet id is the very first byte. switch it to the wrong type
        bytes[0] = 0xA6;

        assert_matches!(
            QuestQst::from_bytes(&mut bytes.deref()),
            Err(QuestQstError::DataFormatError(..))
        );
    }

    #[test]
    pub fn error_when_qst_data_packet_ids_do_not_all_match() {
        let qst = QuestQst::from_file(Path::new("../test-assets/q058-ret-gc.online.qst")).unwrap();
        let mut bytes = qst.to_bytes().unwrap();

        // switch packet id of the first data packet to the wrong type
        bytes[QuestHeaderPacket::packet_size() * 2] = 0xA7;

        assert_matches!(
            QuestQst::from_bytes(&mut bytes.deref()),
            Err(QuestQstError::DataFormatError(..))
        );
    }
}
